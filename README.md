Cursor Prompt: Build Our AI-Facilitated Code & Learning Graph System
Context & Goal
We want a finished system (primarily in Python for the backend) that does the following:

Monitors code changes generated by AI (Cursor) and user commits via a local Git repository.

Sends those changes to Google Gemini (a Large Language Model) for analysis of newly introduced topics (concepts/technologies).

Builds & Maintains two knowledge graphs:

A per-project learning graph of all newly introduced topics and prerequisites.

A global “Master Brain” that merges all topics across all projects.

Tracks Learning for each topic: the user can explicitly mark any topic as “Completed,” which updates the graphs.

Provides a user interface (web-based) that visualizes these graphs, supports searching, and zooms to relevant sub-graphs.

We assume we cannot directly access a “Cursor API” for code changes, so we will rely on Git commits (and the AI output text) to detect new code. That means:

Every time the user finishes an AI generation or is ready to commit changes, we capture the new code, generate a diff, and forward it to the backend.

The backend calls Gemini with that diff to parse out relevant topics.

Tech Stack Requirements
Backend: Python

Use a common framework such as FastAPI (or Flask if desired) to implement REST endpoints.

Local Git Integration for detecting diffs (possibly via a library like GitPython or by calling git diff commands).

Interact with the Gemini LLM using an HTTP request or gRPC (depending on how Gemini is exposed) to get structured data about new topics.

Data Storage

For the topic graphs:

Use either a simple store with NetworkX (in-memory or persisted via JSON/SQLite) or a graph database (e.g., Neo4j).

Each node:

topic_id (string)

display_name (string)

status (e.g., “NOT_LEARNED” or “LEARNED”)

prerequisites (list of other topic_ids)

For each project: maintain a separate sub-graph or a flag on each topic node.

A master brain that consolidates topics across all projects.

Front-End

A React (or Vue, or Angular) single-page app that:

Displays each project’s learning graph, with edges to show dependencies.

Displays the merged “master brain.”

Allows searching for a topic node and auto-zooming to it.

Allows marking topics as “Completed.”

Possibly uses a library like D3.js, Vis.js, or Cytoscape.js to visualize the graph.

Detailed Specifications
Local Git Integration

When the user is ready to checkpoint code:

They commit in Git.

The backend has a mechanism (e.g., a command-line call to git diff HEAD~1 HEAD, or using the GitPython library) to extract the lines that changed.

Along with the user prompt or AI code snippet, the backend then calls Gemini.

Calling Google Gemini

Prompt Construction: Provide the code diff plus short instructions:

“Identify newly introduced programming concepts or technologies in the following code. Return a JSON structure listing:

new_topics (with a topic_id, display_name, short_description)

each topic’s prerequisites as an array of other topic IDs or concept names.

any relevant relationships (parent/child).”

Response Parsing: The backend receives JSON from Gemini, then updates:

The project’s local knowledge graph.

The global “master brain,” merging or linking identical topics.

Data Model

Proposed minimal schema:

py
Copy
Edit
class Topic(BaseModel):
    topic_id: str
    display_name: str
    status: str  # "NOT_LEARNED", "LEARNED"
    prerequisites: List[str] = []
    short_description: Optional[str] = None

class Project(BaseModel):
    project_id: str
    name: str
    topic_ids: List[str] = []
Internally, we can maintain each project’s graph in a NetworkX DiGraph or store them in a DB.

The “master brain” can be another structure. Or we keep a single global graph with a field on each node that indicates which projects it belongs to.

API Endpoints (FastAPI Example)

POST /api/v1/projects/{project_id}/analyze-diff

Request Body:

json
Copy
Edit
{
  "git_diff": "string containing code changes",
  "prompt": "the user prompt text, if available",
  "ai_output": "the snippet or final code block from AI"
}
Logic:

Send git_diff (and any relevant context) to Gemini.

Parse the returned JSON for new topics & prerequisites.

Update the project’s knowledge graph + master brain.

Return updated list of topics or success status.

GET /api/v1/projects/{project_id}/topics

Returns all topics for that project in a list (or a structured representation of the graph).

POST /api/v1/topics/{topic_id}/complete

Marks topic topic_id as “LEARNED” for the user.

GET /api/v1/master-graph

Returns the entire merged “master brain” data structure.

Front-End

React (or similar) with:

A page to view a specific project’s topic graph.

On load, calls GET /api/v1/projects/{project_id}/topics.

Renders each topic node (with color or style based on status).

Edges shown from each node to its prerequisites.

Implement a “Search” bar: search by partial display_name.

On find, highlight or zoom to that node.

A page or tab for the master brain (global graph).

Similar rendering, but merges topics from all projects.

If a topic is completed in any project, it’s shown completed globally.

Marking Topics Completed

User-driven: in the front-end, user can click a node → see a “Mark as Learned” button → triggers POST /api/v1/topics/{topic_id}/complete.

The backend sets the node status to “LEARNED.”

If the same topic_id appears in multiple projects, it should automatically appear as “LEARNED” in all.

Storing & Persisting Data

We can store all data in:

A single-file SQLite DB.

Or just JSON files on disk if the scale is small.

The local Git repository is used only to detect and gather diffs, not for storing the topic graphs.

Deployment

Local: Both the FastAPI backend and the front-end can run on a local machine (e.g., high-end laptop).

Possibly use Docker Compose to spin up a container for the backend and a container for the front-end.

Edge Cases

If Gemini returns repeated or nearly identical topics, attempt some topic ID de-duplication (like string matching or ID normalization).

If the user commits frequently with trivial changes, you may want to skip or batch certain diffs if no meaningful code changes occur.

Example Flow

User starts a project, sets up local Git.

First code snippet: “Hello World in C++.”

Commit → Plugin or user triggers “Analyze Diff.”

The system calls Gemini to discover new topics, e.g. ["Basic IO in C++"].

This is added to project’s graph.

Second snippet: “Add concurrency with <thread> library.”

Commit → Again, we call Gemini, it finds “Multithreading in C++,” which depends on “Basic Threading Concepts.”

Front-End shows:

Node: “Multithreading in C++”

“Prerequisites”: “Basic Threading Concepts,” “Memory Management in C++.”

User marks “Basic Threading Concepts” → “LEARNED.”

Prompt Instructions to Cursor
Step-by-step, generate:

Backend (Python, FastAPI)

A minimal structure for environment setup (e.g., requirements.txt).

A main app with the endpoints described above.

Integration with local Git to get diffs.

A function to call Gemini with a well-formed prompt and parse the JSON response.

Logic to store and update a project’s topic graph plus a master brain.

Graph Management

Possibly use networkx for in-memory graph representation.

Or store nodes/edges in a small SQLite DB.

Provide utility functions like add_topics_to_project_graph(...), merge_into_master_brain(...), etc.

Front-End (React)

Basic scaffolding: create-react-app or Vite setup.

A page for listing all projects.

A page showing the chosen project’s graph (with a library like Cytoscape.js or Vis.js).

A page for the master brain.

“Search bar” for zooming.

“Mark as learned” button on each topic node.

Instructions

Provide a self-contained or near-complete example.

Show how to run the backend (e.g., uvicorn main:app --reload) and the front-end.

Show an example of sending a POST request to /api/v1/projects/{project_id}/analyze-diff with mock data.

Final Prompt to Cursor
Below is the single composite prompt you can paste into Cursor (or any LLM) to generate the solution:

Title: “Build a Full Python + React System for AI-Facilitated Code & Learning Graphs with Local Git Integration”

Overview:

Use FastAPI in Python to create a backend.

Integrate with local Git (via GitPython or shell calls) to obtain diffs from the last commit.

Send diffs and context to Google Gemini to extract new topics + prerequisites.

Store data in an in-memory or SQLite-based topic graph for each project, plus a global “master brain.”

Provide endpoints to mark topics as learned.

Develop a React front-end to visualize these graphs (with Cytoscape.js or Vis.js).

Key Requirements:

Backend Endpoints:

POST /api/v1/projects/{project_id}/analyze-diff: Takes JSON with git_diff, prompt, and ai_output. Calls Gemini, updates the project’s graph & master brain.

GET /api/v1/projects/{project_id}/topics: Returns project’s topics in JSON.

POST /api/v1/topics/{topic_id}/complete: Marks a topic as “LEARNED.”

GET /api/v1/master-graph: Returns the global knowledge graph.

Gemini Integration: Provide a helper function to format a prompt with the code diff, parse the JSON response with new topics, and unify them in the data model.

Data Model: A minimal Topic structure (topic_id, display_name, status, prerequisites, short_description), plus references to which project(s) the topic belongs to.

Graph Library: Use networkx or an equivalent.

Front-End:

React app with a route for each project’s graph and a route for the master brain.

Graph rendering with dynamic zoom, node selection, searching, and color/status changes for “LEARNED” vs. “NOT_LEARNED.”

Button to mark a selected topic as learned, calling the appropriate endpoint.

Local Git: Show an example script or function that (1) identifies the last commit, (2) extracts the diff, and (3) returns that as text for the endpoint.

Deliverables:

A fully working Python codebase (FastAPI) with the described endpoints.

A React-based front-end that can be run locally (or containerized).

Documentation on how to start the backend and front-end, how to link them, and how to test the endpoints.

Edge Cases:

If Gemini returns duplicate topics or nearly identical topics, unify them under a single topic_id.

Handling trivial diffs that may not introduce new topics.

Please produce the implementation in one or more code blocks or files (e.g., backend/main.py, frontend/src/App.js, etc.), along with an overview of how to build and run the system from scratch.
